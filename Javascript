Javascript:

- const -> Palabra reservada para declarar una constante.

- var -> Palabra reservada para declarar una variable.

- let -> Palabra reservada para declarar una variable, la diferencia con var es que a las variables declaradas
  como let, solo se tiene acceso a ellas en donde fueron declaradas.

- <script src="./script.js"></script> -> Hace referencia a el archivo Javascript desde HTML.

- == Compara solamente valor.

- === Compara valor y tipo de dato.

- Template String: console.log(`Mi nombre es ${nombre}`);

- Asincron√≠smo -> Acci√≥n que no ocurre al mismo tiempo. La finalizaci√≥n de la operaci√≥n I/O se se√±aliza m√°s tarde, mediante un mecanismo espec√≠fico
  como por ejemplo un callback, una promesa o un evento, lo que hace posible que la respuesta
  sea procesada en diferido.

- API -> Interfaz de programaci√≥n de aplicaciones (Application Programming Interface). Es un conjunto de
  rutinas que provee acceso a funciones de un determinado software.

- Concurrencia -> Cuando dos o m√°s tareas progresan simult√°neamente.

- Paralelismo -> Cuando dos o m√°s tareas se ejecutan, literalmente, a la vez, en el mismo instante de tiempo

- Bloqueante -> Una llamada u operaci√≥n bloqueante no devuelve el control a nuestra aplicaci√≥n hasta que se ha
  completado. Por tanto el thread queda bloqueado en estado de espera.

- S√≠ncrono -> Es frecuente emplear ‚Äòbloqueante‚Äô y ‚Äòs√≠ncrono‚Äô como sin√≥nimos, dando a entender que toda la
  operaci√≥n de entrada/salida se ejecuta de forma secuencial y, por tanto, debemos esperar a que
  se complete para procesar el resultado.

- Call Stack -> La pila de llamadas, se encarga de albergar las instrucciones que deben ejecutarse. Nos indica en
  que punto del programa estamos, por donde vamos.

- Heap -> Regi√≥n de memoria libre, normalmente de gran tama√±o, dedicada al alojamiento din√°mico de
  objetos. Es compartida por todo el programa y controlada por un recolector de basura que se
  encarga de liberar aquello que no se necesita.

- Cola o Queue -> Cada vez que nuestro programa recibe una notificaci√≥n del exterior o de otro contexto distinto al
  de la aplicaci√≥n, el mensaje se inserta en una cola de mensajes pendientes y se registra su
  callback correspondiente.

- Eventloop o Loop de eventos -> Cuando la pila de llamadas (call stack) se vac√≠a, es decir, no hay nada m√°s que ejecutar, se
  procesan los mensajes de la cola. Con cada ‚Äòtick‚Äô del bucle de eventos, se procesa un nuevo
  mensaje.

- Hoisting (Elevaci√≥n) -> Sugiere que las declaraciones de variables y funciones son f√≠sicamente movidas al comienzo del
  c√≥digo en tiempo de compilaci√≥n.

  ¬øQu√© se eleva?

  - var (solo la declaraci√≥n)
  - function (se elevan por completo)
  - import est√°ticos (se elevan por completo)
  - class (NO se elevan)
  - let / const (Se elevan a la temporal dead zone)
    Referencia: https://www.youtube.com/watch?v=uI6o97A4IrI&ab_channel=LaCocinadelC%C3%B3digo

- DOM -> DOM permite acceder y manipular las p√°ginas XHTML como si fueran documentos XML. De
  hecho, DOM se dise√±√≥ originalmente para manipular de forma sencilla los documentos XML.

- XML -> Lenguaje de marcado creado para la transferencia de informaci√≥n, legible tanto para seres
  humanos como para aplicaciones inform√°ticas, y basado en una sencillez extrema y una r√≠gida
  sintaxis. As√≠ como el HTML estaba basado y era un subconjunto de SGML, la reformulaci√≥n del
  primero bajo la sintaxis de XML dio lugar al XHTML; XHTML es, por tanto, un subconjunto de
  XML.

- Events -> Comportamientos del usuario que interact√∫a con una p√°gina que pueden detectarse para lanzar
  una acci√≥n, como por ejemplo que el usuario haga click en un elemento (onclick), que elija una
  opci√≥n de un desplegable (onselect), que pase el rat√≥n sobre un objeto (onmouseover), etc.
  Compilar -> Compilar es generar c√≥digo ejecutable por una m√°quina, que puede ser f√≠sica o abstracta como
  la m√°quina virtual de Java.

- Transpilar -> Transpilar es generar a partir de c√≥digo en un lenguaje c√≥digo en otro lenguaje. Es decir, un
  programa produce otro programa en otro lenguaje cuyo comportamiento es el mismo que el
  original.

- Scope -> Se refiere a el alcance que tiene una variable dentro del c√≥digo, puede ser Global, local.

  Global: Las variables globales pueden ser accedidas desde cualquier lugar de nuestro programa. Son variables declaradas fuera de toda funci√≥n o bloque de c√≥digo, sin importar si las declaramos con var, let o const.
  Las variables globales, van a estar en memoria durante toda la ejecuci√≥n del programa.

  Local: Las variables locales solo se pueden acceder desde una parte de de nuestro programa.
  Local de funci√≥n: Accesibles dentro de toda la funci√≥n pero no fuera de la misma.
  Variables declaradas con var.
  Local de bloque: Accesibles dentro de todo el bloque, pero no fuera del mismo. Variables declaradas con let o const.

  Las variables locales van a estar en memoria durante la ejecuci√≥n de la funci√≥n o bloque.

  Nota: Declarar las variables con el scope m√°s reducido posible.

- Lexical Scope / √°mbito l√©xico -> En JavaScript las funciones tienen su propio √°mbito l√©xico, lo que quiere decir que depende de c√≥mo son declaradas en el c√≥digo y no de cuando se ejecutan.

El int√©rprete de JavaScript funciona desde el √°mbito de ejecuci√≥n actual y funciona hasta encontrar la variable en cuesti√≥n. Si la variable no se encuentra en ning√∫n √°mbito, se genera una excepci√≥n.

Este tipo de b√∫squeda se llama √°mbito l√©xico. El alcance de una variable se define por su ubicaci√≥n dentro del c√≥digo fuente, y las funciones anidadas tienen acceso a las variables declaradas en su alcance externo. No importa de d√≥nde se llame una funci√≥n, o incluso c√≥mo se llama, su alcance l√©xico depende solo de d√≥nde se declar√≥ la funci√≥n.

- Closure: Las funciones anidadas que recuerdan el conjunto de variables a las que pod√≠an acceder, por m√°s que se les invoque desde otro lugar, desde otro scope.

Para crear una closure necesitamos de 3 ingredientes:

- Una funci√≥n que se encuentre dentro de otra funci√≥n, es decir una funci√≥n anidada
- Alguna variable que se encuentre dentro de la funci√≥n m√°s grande y que la funci√≥n de adentro la utilice de alguna manera.
- Invocar a la funci√≥n interna pero no desde el scope donde est√° escrita.

Ejemplo:
function crearContador() {
let contador = 0;

return function incrementar() {
contador = contador + 1;
return contador;
};
}

const contador1 = crearContador();

Referencia: https://www.youtube.com/watch?v=JXG_gQ0OF74&ab_channel=LaCocinadelC%C3%B3digo

- Call Stack (Pila de ejecuci√≥n) -> A las pilas tambi√©n se les conoce como LIFO (Last In First Out)

- Stacktrace -> Es la secuencia de llamadas que se fueron dando durante la ejecuci√≥n de un programa hasta que sucedi√≥ un excepci√≥n
  o un error inesperado.

- Tipado din√°mico -> Las variables no tienen un tipo de dato particular asociado, podemos asignarle y re-asignarle cualquier valor a cualquier variable.

- Tipado d√©bil -> Podemos realizar operaciones entre valores de distintos tipos.

- Coerci√≥n de tipos -> Conversi√≥n impl√≠cita de tipos que realiza el motor de JS para poder concretar una operaci√≥n.

- Tipo de una variable -> Se determina cuando se ejecute la l√≠nea de c√≥digo que contiene a esa variable. Depende de la operaci√≥n que se est√° realizando con ella.

- Tipos de datos primitivos -> Son tipos de datos b√°sicos, no poseen m√©todos ni propiedades, son inmutables.
  strings, number, boolean, null, undefined, symbol, bigint.
- NaN -> Not a Number, es de tipo number y es el resultado de c√≥mputos inv√°lidos.

- Valores falsos -> Valores que van a ser evaluados como false (adem√°s de false): '', 0, null y NaN. Cualquier otro valor va a ser verdadero.

- Object Wrapper -> Objeto que envuelve a un valor primitivo cuando queremos acceder a una propiedad o llamar a un m√©todo del mismo.
  Es temporal porque el motor lo utiliza solo por una fracci√≥n de segundo, despu√©s lo desecha, lo borra de la memoria.

Null -> Es el tipo de dato para representar la ausencia de valor. Sirve para decir que una variable no contiene nada, est√° vac√≠a
o que todav√≠a no conocemos su valor. Es un tipo de dato aparte y que solo tiene un valor posible: null.

undefined -> Significa tipo de dato desconocido. Es un valor que deber√≠amos dejar para que el motor de JS asigne autom√°ticamente.
Se muestra undefined cuando a√∫n no se le dio ning√∫n valor, no se recibi√≥ ese par√°metro,
una funci√≥n se termin√≥ de ejecutar hasta el final sin devolver ning√∫n valor.

HEAP -> Es el √°rea de memoria destinada para almacenar objetos.

Referencia -> Es la posici√≥n de memoria que se usa para acceder a un objeto.

import / export: Con estas palabras se puede importar y exportar m√≥dulos.

props -> son la colecci√≥n de datos que un componente recibe del contenedor padre, y que pueden usarse para definir los elementos de React que retornar√° el componente.

Pilares de la POO:
Abstracci√≥n -> Es una manera de reducir la complejidad y permitir un dise√±o e implementaci√≥n m√°s eficientes en sistemas de software complejos.

Encapsulamiento -> Es guardar, proteger, guardar o limitar el acceso de cierto atributos y/o propiedades en nuestros prototipos y objetos.
Cuando hablamos de **encapsulamiento **hablamos de:
Esconder m√©todos y atributos üëª
No permitir la alteraci√≥n de m√©todos y atributos ‚ùå

                Encapsulamiento en JavaScript
                No permitir la alteraci√≥n de m√©todos y atributos ‚ùå

                Formas de aplicar encapsulamiento en JavaScript
                Getters y setters üñê
                Namespaces üôÇ
                Object.defineProperties üéà
                M√≥dulo de ES6 ü§ù

Nota: Se hace uso de los m√©todos get y set para limitar la modificaci√≥n de determinados par√°metros del prototipo clase.
TODO: Investigar m√°s respecto a como se aplican.

Herencia -> Palabra reservada "extends,
Super: La palabra clave super es usada para acceder y llamar funciones del padre de un objeto.

Polimorfismo -> Permite a nuestras subclases cambiar o anular los comportamientos de los m√©todos y atributos del prototipo madre, de la clase madre.
Aunque herede las propiedades, el polimorfismo permite cambiar su comportamiento.
Polimorfismo de Inclusi√≥n (JS): La habilidad para redefinir por completo el m√©todo de una superclase en una subclase.
El polimorfismo permite sobrescribir m√©todos.

static -> Palabra reservada que nos permite acceder a los atributos sin crear un objeto o una instancia de un prototipo (clase).
Nota: El prototipo Object tiene m√©todos est√°ticos, por ejemplo(Object.keys, Object.getOwnPropertyNames,Object.entries(), Object.getOwnPropertyDescriptors())).

Las variables son referencias a un espacio en memoria.
üé© Los navegadores web usan dos tipos de memorias: Stack y Heap.
üìÅ La memoria Stack es muy r√°pida, pero sin tanto espacio. Aqu√≠ se guardan los valores primitivos (booleanos, strings, n√∫meros‚Ä¶).
üå™ La memoria Heap es m√°s lenta, pero permite guardar enormes cantidades de informaci√≥n (son como los tornados: grandes, lentos y desordenados). En esta memoria guardamos los valores de los objetos ({...}).

Las variables son una referencia a un espacio en memoria. Dependiendo del tipo de valor que sean ser√°n ubicadas en alguna de las dos tipos de memoria:

Stack - Mucho m√°s r√°pida, pero sin tanto espacio
Heap - M√°s lenta, pero con mucho m√°s espacio
Las variables que no tienen un valor de tipo objeto, son almacenadas en la memoria stack. Las variables que tienen como valor un objeto, funcionan de una manera diferente:

El valor (objeto) es guardada en la memoria heap
En la memoria stack se guarda un apuntador (pointer) hacia la memoria heap
Es por esto que cuando nosotros asignamos una variable que tiene como valor un objeto, a una nueva variable, lo √∫nico que hacemos es asignar el apuntador. Es as√≠ que al modificar el objeto, en cualquiera de las dos variables, los cambios se reflejan en las dos

Shallow Copy: Se refiere a la forma de crear un nuevo objeto a partir de las propiedades de otro.
Esta copia solo se hace a un nivel alto, no se hace con objetos dentro de objetos (nested objects), lo que provoca que la modificaci√≥n de una de sus propiedades, modifique el objeto principal.

Recursividad: Es cuando una funci√≥n se llama a si misma y crea una nueva ejecuci√≥n de la funci√≥n.
Ejemplo:

const numeritos = [8, 3, 4, 5, 0, 1, 30, 40];

function recursiva(numbersArray) {
if (numbersArray.length != 0) {
const firstNum = numbersArray[0];
console.log(firstNum);
numbersArray.shift();
recursiva(numbersArray);
}
}

recursiva(numeritos);

RORO: es un patr√≥n de dise√±o que consiste en crear una funci√≥n que devuelve un objeto.
RO -> Recibir un objeto
RO -> Retornar un objeto

Promesas: Las promesas son los conceptos b√°sicos de la programaci√≥n as√≠ncrona en JavaScript.

¬øQu√© significa as√≠ncrono?
El t√©rmino as√≠ncrono se refiere al concepto de que m√°s de una cosa ocurre al mismo tiempo, o m√∫ltiples cosas relacionadas ocurren sin esperar a que la previa se haya completado.

¬øQu√© es la programaci√≥n as√≠ncrona?
La programaci√≥n as√≠ncrona es un m√©todo de programaci√≥n que permite que diferentes partes del c√≥digo se ejecuten en diferentes momentos, en lugar de hacerlo inmediatamente.

Esto se requiere principalmente cuando queremos obtener informaci√≥n de alg√∫n servidor remoto y escribir c√≥digo que haga algo con lo que devolvi√≥ el servidor.

El Objeto Promesa:
Una promesa es un objeto nativo de JavaScript que tiene dos caracter√≠sticas: 1. Recibe un √∫nico argumento que es una funci√≥n. Esta funci√≥n necesita tener dos argumentos, una funci√≥n de resoluci√≥n y una funci√≥n de rechazo. El c√≥digo escrito dentro de la promesa necesita usar una de estas dos funciones. 2. Se puede esperar usando el m√©todo then (y otros m√©todos similares) o la instrucci√≥n await.

Una funci√≥n as√≠ncrona se define por una funci√≥n que, en lugar de devolver el valor que se supon√≠a que deb√≠a devolver, devuelve un objeto Promesa, que eventualmente se resolver√° y le dar√° la respuesta al usuario.

Async and Await:

---

## Arreglos -> M√©todos m√°s usados:

foreach: Este m√©todo sirve para iterar sobre cada elemento del arreglo.

const letters = ["a", "b", "c", "d", "e"];

letters.forEach((element) => {
console.log(element);
});

a
b
c
d
e

---

Map: Crea un nuevo array con los resultados de la llamada a la funci√≥n indicada aplicados a cada uno de sus elementos.

es INMUTABLE por lo tanto no modifica el array original, sino que crea uno nuevo con la ‚Äútransformaci√≥n‚Äù aplicada.

Adem√°s, mantienes el mismo length que el array original, te devuelve en el nuevo array la misma cantidad que el array que le aplicaste el m√©todo.

Nota: forEach() no crea o devuelve, por defecto, un nuevo array con los elementos modificados, en cambio .map() si.

const numbers = [1, 2, 3, 4, 5];
numbers.map((item) => console.log(item \* 2));

2
4
6
8
10

---

Filter: Lo que hace es filtrar el array original en base a una condici√≥n, los que la cumplan estar√°n en el nuevo array creado.

Por lo tanto filter() es inmutable y el nuevo array creado solamente puede contener:

- cero coincidencias
- todas coincidencias
- algunas coincidencias
  Pero nunca m√°s coincidencias que el tama√±o del array original.

  ***

Reduce: Este m√©todo REDUCE, efectivamente hace eso. Solo reduce a un solo valor y no devuelve otro array, simplemente un valor.

Se utiliza much√≠simo para hacer c√°lculos a partir de la informaci√≥n de un array.

En su composici√≥n, a primeras, tiene como argumentos de la funci√≥n del primer par√°metro, al acumulador y como segundo par√°metro al elemento por el que va iterando el loop. Y como segundo argumento del reduce(), se pasa el valor inicial del acumulador.

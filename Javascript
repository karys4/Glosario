Javascript:

- const -> Palabra reservada para declarar una constante.

- var -> Palabra reservada para declarar una variable.

- let -> Palabra reservada para declarar una variable, la diferencia con var es que a las variables declaradas
  como let, solo se tiene acceso a ellas en donde fueron declaradas.

- <script src="./script.js"></script> -> Hace referencia a el archivo Javascript desde HTML.

- == Compara solamente valor.

- === Compara valor y tipo de dato.

- Template String: console.log(`Mi nombre es ${nombre}`);

- Asincron√≠smo -> Acci√≥n que no ocurre al mismo tiempo. La finalizaci√≥n de la operaci√≥n I/O se se√±aliza m√°s tarde, mediante un mecanismo espec√≠fico
  como por ejemplo un callback, una promesa o un evento, lo que hace posible que la respuesta
  sea procesada en diferido.

- API -> Interfaz de programaci√≥n de aplicaciones (Application Programming Interface). Es un conjunto de
  rutinas que provee acceso a funciones de un determinado software.

- Concurrencia -> Cuando dos o m√°s tareas progresan simult√°neamente.

- Paralelismo -> Cuando dos o m√°s tareas se ejecutan, literalmente, a la vez, en el mismo instante de tiempo

- Bloqueante -> Una llamada u operaci√≥n bloqueante no devuelve el control a nuestra aplicaci√≥n hasta que se ha
  completado. Por tanto el thread queda bloqueado en estado de espera.

- S√≠ncrono -> Es frecuente emplear ‚Äòbloqueante‚Äô y ‚Äòs√≠ncrono‚Äô como sin√≥nimos, dando a entender que toda la
  operaci√≥n de entrada/salida se ejecuta de forma secuencial y, por tanto, debemos esperar a que
  se complete para procesar el resultado.

- Call Stack -> La pila de llamadas, se encarga de albergar las instrucciones que deben ejecutarse. Nos indica en
  que punto del programa estamos, por donde vamos.

- Heap -> Regi√≥n de memoria libre, normalmente de gran tama√±o, dedicada al alojamiento din√°mico de
  objetos. Es compartida por todo el programa y controlada por un recolector de basura que se
  encarga de liberar aquello que no se necesita.

- Cola o Queue -> Cada vez que nuestro programa recibe una notificaci√≥n del exterior o de otro contexto distinto al
  de la aplicaci√≥n, el mensaje se inserta en una cola de mensajes pendientes y se registra su
  callback correspondiente.

- Eventloop o Loop de eventos -> Cuando la pila de llamadas (call stack) se vac√≠a, es decir, no hay nada m√°s que ejecutar, se
  procesan los mensajes de la cola. Con cada ‚Äòtick‚Äô del bucle de eventos, se procesa un nuevo
  mensaje.

- Hoisting -> Sugiere que las declaraciones de variables y funciones son f√≠sicamente movidas al comienzo del
  c√≥digo en tiempo de compilaci√≥n.

- DOM -> DOM permite acceder y manipular las p√°ginas XHTML como si fueran documentos XML. De
  hecho, DOM se dise√±√≥ originalmente para manipular de forma sencilla los documentos XML.

- XML -> Lenguaje de marcado creado para la transferencia de informaci√≥n, legible tanto para seres
  humanos como para aplicaciones inform√°ticas, y basado en una sencillez extrema y una r√≠gida
  sintaxis. As√≠ como el HTML estaba basado y era un subconjunto de SGML, la reformulaci√≥n del
  primero bajo la sintaxis de XML dio lugar al XHTML; XHTML es, por tanto, un subconjunto de
  XML.

- Events -> Comportamientos del usuario que interact√∫a con una p√°gina que pueden detectarse para lanzar
  una acci√≥n, como por ejemplo que el usuario haga click en un elemento (onclick), que elija una
  opci√≥n de un desplegable (onselect), que pase el rat√≥n sobre un objeto (onmouseover), etc.
  Compilar -> Compilar es generar c√≥digo ejecutable por una m√°quina, que puede ser f√≠sica o abstracta como
  la m√°quina virtual de Java.

- Transpilar -> Transpilar es generar a partir de c√≥digo en un lenguaje c√≥digo en otro lenguaje. Es decir, un
  programa produce otro programa en otro lenguaje cuyo comportamiento es el mismo que el
  original.

- Scope -> Se refiere a el alcance que tiene una variable dentro del c√≥digo, puede ser Global, local.

- Lexical Scope / √°mbito l√©xico -> En JavaScript las funciones tienen su propio √°mbito l√©xico, lo que quiere decir que depende de c√≥mo son declaradas en el c√≥digo y no de cuando se ejecutan.

- Call Stack (Pila de ejecuci√≥n) -> A las pilas tambi√©n se les conoce como LIFO (Last In First Out)

- Stacktrace -> Es la secuencia de llamadas que se fueron dando durante la ejecuci√≥n de un programa hasta que sucedi√≥ un excepci√≥n 
o un error inesperado. 

- Tipado din√°mico -> Las variables no tienen un tipo de dato particular asociado, podemos asignarle y re-asignarle cualquier valor a cualquier variable.

- Tipado d√©bil -> Podemos realizar operaciones entre valores de distintos tipos.

- Coerci√≥n de tipos -> Conversi√≥n impl√≠cita de tipos que realiza el motor de JS para poder concretar una operaci√≥n. 

- Tipo de una variable -> Se determina cuando se ejecute la l√≠nea de c√≥digo que contiene a esa variable. Depende de la operaci√≥n que se est√° realizando con ella. 

- Tipos de datos primitivos -> Son tipos de datos b√°sicos, no poseen m√©todos ni propiedades, son inmutables. 
                               strings, number, boolean, null, undefined, symbol, bigint.
- NaN -> Not a Number, es de tipo number y es el resultado de c√≥mputos inv√°lidos. 

- Valores falsos -> Valores que van a ser evaluados como false (adem√°s de false): '', 0, null y NaN. Cualquier otro valor va a ser verdadero.

- Object Wrapper -> Objeto que envuelve a un valor primitivo cuando queremos acceder a una propiedad o llamar a un m√©todo del mismo.
  Es temporal porque el motor lo utiliza solo por una fracci√≥n de segundo, despu√©s lo desecha, lo borra de la memoria.

Null -> Es el tipo de dato para representar la ausencia de valor. Sirve para decir que una variable no contiene nada, est√° vac√≠a
         o que todav√≠a no conocemos su valor. Es un tipo de dato aparte y que solo tiene un valor posible: null.

undefined -> Significa tipo de dato desconocido. Es un valor que deber√≠amos dejar para que el motor de JS asigne autom√°ticamente.
            Se muestra undefined cuando a√∫n no se le dio ning√∫n valor, no se recibi√≥ ese par√°metro,
            una funci√≥n se termin√≥ de ejecutar hasta el final sin devolver ning√∫n valor.

HEAP -> Es el √°rea de memoria destinada para almacenar objetos.

Referencia -> Es la posici√≥n de memoria que se usa para acceder a un objeto. 

import / export: Con estas palabras se puede importar y exportar m√≥dulos. 

props -> son la colecci√≥n de datos que un componente recibe del contenedor padre, y que pueden usarse para definir los elementos de React que retornar√° el componente.


Pilares de la POO:
Abstracci√≥n -> Es una manera de reducir la complejidad y permitir un dise√±o e implementaci√≥n m√°s eficientes en sistemas de software complejos.

Encapsulamiento -> Es guardar, proteger, guardar o limitar el acceso de cierto atributos y/o propiedades en nuestros prototipos y objetos.
                Cuando hablamos de **encapsulamiento **hablamos de:
                Esconder m√©todos y atributos üëª
                No permitir la alteraci√≥n de m√©todos y atributos ‚ùå

                Encapsulamiento en JavaScript
                No permitir la alteraci√≥n de m√©todos y atributos ‚ùå
                
                Formas de aplicar encapsulamiento en JavaScript
                Getters y setters üñê
                Namespaces üôÇ
                Object.defineProperties üéà
                M√≥dulo de ES6 ü§ù
Nota: Se hace uso de los m√©todos get y set para limitar la modificaci√≥n de determinados par√°metros del prototipo clase.
TODO: Investigar m√°s respecto a como se aplican.



Herencia -> Palabra reservada "extends, 
            Super: La palabra clave super es usada para acceder y llamar funciones del padre de un objeto.

Polimorfismo -> Permite a nuestras subclases cambiar o anular los comportamientos de los m√©todos y atributos del prototipo madre, de la clase madre. 
                Aunque herede las propiedades, el polimorfismo permite cambiar su comportamiento.
                Polimorfismo de Inclusi√≥n (JS): La habilidad para redefinir por completo el m√©todo de una superclase en una subclase.
                El polimorfismo permite sobrescribir m√©todos. 

static -> Palabra reservada que nos permite acceder a los atributos sin crear un objeto o una instancia de un prototipo (clase).
          Nota: El prototipo Object tiene m√©todos est√°ticos, por ejemplo(Object.keys, Object.getOwnPropertyNames,Object.entries(), Object.getOwnPropertyDescriptors())).

Las variables son referencias a un espacio en memoria.
üé© Los navegadores web usan dos tipos de memorias: Stack y Heap.
üìÅ La memoria Stack es muy r√°pida, pero sin tanto espacio. Aqu√≠ se guardan los valores primitivos (booleanos, strings, n√∫meros‚Ä¶).
üå™ La memoria Heap es m√°s lenta, pero permite guardar enormes cantidades de informaci√≥n (son como los tornados: grandes, lentos y desordenados). En esta memoria guardamos los valores de los objetos ({...}).

Las variables son una referencia a un espacio en memoria. Dependiendo del tipo de valor que sean ser√°n ubicadas en alguna de las dos tipos de memoria:

Stack - Mucho m√°s r√°pida, pero sin tanto espacio
Heap - M√°s lenta, pero con mucho m√°s espacio
Las variables que no tienen un valor de tipo objeto, son almacenadas en la memoria stack. Las variables que tienen como valor un objeto, funcionan de una manera diferente:

El valor (objeto) es guardada en la memoria heap
En la memoria stack se guarda un apuntador (pointer) hacia la memoria heap
Es por esto que cuando nosotros asignamos una variable que tiene como valor un objeto, a una nueva variable, lo √∫nico que hacemos es asignar el apuntador. Es as√≠ que al modificar el objeto, en cualquiera de las dos variables, los cambios se reflejan en las dos

Shallow Copy: Se refiere a la forma de crear un nuevo objeto a partir de las propiedades de otro. 
              Esta copia solo se hace a un nivel alto, no se hace con objetos dentro de objetos (nested objects), lo que provoca que la modificaci√≥n de una de sus propiedades, modifique el objeto principal.

Recursividad: Es cuando una funci√≥n se llama a si misma y crea una nueva ejecuci√≥n de la funci√≥n. 
Ejemplo:

const numeritos = [8, 3, 4, 5, 0, 1, 30, 40];

function recursiva(numbersArray) {
  if (numbersArray.length != 0) {
    const firstNum = numbersArray[0];
    console.log(firstNum);
    numbersArray.shift();
    recursiva(numbersArray);
  }
}

recursiva(numeritos);
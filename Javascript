Javascript:

- const -> Palabra reservada para declarar una constante.

- var -> Palabra reservada para declarar una variable.

- let -> Palabra reservada para declarar una variable, la diferencia con var es que a las variables declaradas
  como let, solo se tiene acceso a ellas en donde fueron declaradas.

- <script src="./script.js"></script> -> Hace referencia a el archivo Javascript desde HTML.

- == Compara solamente valor.

- === Compara valor y tipo de dato.

- Template String: console.log(`Mi nombre es ${nombre}`);

- AsincronÃ­smo -> AcciÃ³n que no ocurre al mismo tiempo. La finalizaciÃ³n de la operaciÃ³n I/O se seÃ±aliza mÃ¡s tarde, mediante un mecanismo especÃ­fico
  como por ejemplo un callback, una promesa o un evento, lo que hace posible que la respuesta
  sea procesada en diferido.

- API -> Interfaz de programaciÃ³n de aplicaciones (Application Programming Interface). Es un conjunto de
  rutinas que provee acceso a funciones de un determinado software.

- Concurrencia -> Cuando dos o mÃ¡s tareas progresan simultÃ¡neamente.

- Paralelismo -> Cuando dos o mÃ¡s tareas se ejecutan, literalmente, a la vez, en el mismo instante de tiempo

- Bloqueante -> Una llamada u operaciÃ³n bloqueante no devuelve el control a nuestra aplicaciÃ³n hasta que se ha
  completado. Por tanto el thread queda bloqueado en estado de espera.

- SÃ­ncrono -> Es frecuente emplear â€˜bloqueanteâ€™ y â€˜sÃ­ncronoâ€™ como sinÃ³nimos, dando a entender que toda la
  operaciÃ³n de entrada/salida se ejecuta de forma secuencial y, por tanto, debemos esperar a que
  se complete para procesar el resultado.

- Call Stack -> La pila de llamadas, se encarga de albergar las instrucciones que deben ejecutarse. Nos indica en
  que punto del programa estamos, por donde vamos.

- Heap -> RegiÃ³n de memoria libre, normalmente de gran tamaÃ±o, dedicada al alojamiento dinÃ¡mico de
  objetos. Es compartida por todo el programa y controlada por un recolector de basura que se
  encarga de liberar aquello que no se necesita.

- Cola o Queue -> Cada vez que nuestro programa recibe una notificaciÃ³n del exterior o de otro contexto distinto al
  de la aplicaciÃ³n, el mensaje se inserta en una cola de mensajes pendientes y se registra su
  callback correspondiente.

- Eventloop o Loop de eventos -> Cuando la pila de llamadas (call stack) se vacÃ­a, es decir, no hay nada mÃ¡s que ejecutar, se
  procesan los mensajes de la cola. Con cada â€˜tickâ€™ del bucle de eventos, se procesa un nuevo
  mensaje.

- Hoisting -> Sugiere que las declaraciones de variables y funciones son fÃ­sicamente movidas al comienzo del
  cÃ³digo en tiempo de compilaciÃ³n.

- DOM -> DOM permite acceder y manipular las pÃ¡ginas XHTML como si fueran documentos XML. De
  hecho, DOM se diseÃ±Ã³ originalmente para manipular de forma sencilla los documentos XML.

- XML -> Lenguaje de marcado creado para la transferencia de informaciÃ³n, legible tanto para seres
  humanos como para aplicaciones informÃ¡ticas, y basado en una sencillez extrema y una rÃ­gida
  sintaxis. AsÃ­ como el HTML estaba basado y era un subconjunto de SGML, la reformulaciÃ³n del
  primero bajo la sintaxis de XML dio lugar al XHTML; XHTML es, por tanto, un subconjunto de
  XML.

- Events -> Comportamientos del usuario que interactÃºa con una pÃ¡gina que pueden detectarse para lanzar
  una acciÃ³n, como por ejemplo que el usuario haga click en un elemento (onclick), que elija una
  opciÃ³n de un desplegable (onselect), que pase el ratÃ³n sobre un objeto (onmouseover), etc.
  Compilar -> Compilar es generar cÃ³digo ejecutable por una mÃ¡quina, que puede ser fÃ­sica o abstracta como
  la mÃ¡quina virtual de Java.

- Transpilar -> Transpilar es generar a partir de cÃ³digo en un lenguaje cÃ³digo en otro lenguaje. Es decir, un
  programa produce otro programa en otro lenguaje cuyo comportamiento es el mismo que el
  original.

- Scope -> Se refiere a el alcance que tiene una variable dentro del cÃ³digo, puede ser Global, local.

  Global: Las variables globales pueden ser accedidas desde cualquier lugar de nuestro programa. Son variables declaradas fuera de toda funciÃ³n o bloque de cÃ³digo, sin importar si las declaramos con var, let o const.
  Las variables globales, van a estar en memoria durante toda la ejecuciÃ³n del programa.

  Local: Las variables locales solo se pueden acceder desde una parte de de nuestro programa.
  Local de funciÃ³n: Accesibles dentro de toda la funciÃ³n pero no fuera de la misma.
  Variables declaradas con var.
  Local de bloque: Accesibles dentro de todo el bloque, pero no fuera del mismo. Variables declaradas con let o const.

  Las variables locales van a estar en memoria durante la ejecuciÃ³n de la funciÃ³n o bloque.

  Nota: Declarar las variables con el scope mÃ¡s reducido posible.

- Lexical Scope / Ã¡mbito lÃ©xico -> En JavaScript las funciones tienen su propio Ã¡mbito lÃ©xico, lo que quiere decir que depende de cÃ³mo son declaradas en el cÃ³digo y no de cuando se ejecutan.

El intÃ©rprete de JavaScript funciona desde el Ã¡mbito de ejecuciÃ³n actual y funciona hasta encontrar la variable en cuestiÃ³n. Si la variable no se encuentra en ningÃºn Ã¡mbito, se genera una excepciÃ³n.

Este tipo de bÃºsqueda se llama Ã¡mbito lÃ©xico. El alcance de una variable se define por su ubicaciÃ³n dentro del cÃ³digo fuente, y las funciones anidadas tienen acceso a las variables declaradas en su alcance externo. No importa de dÃ³nde se llame una funciÃ³n, o incluso cÃ³mo se llama, su alcance lÃ©xico depende solo de dÃ³nde se declarÃ³ la funciÃ³n.

- Call Stack (Pila de ejecuciÃ³n) -> A las pilas tambiÃ©n se les conoce como LIFO (Last In First Out)

- Stacktrace -> Es la secuencia de llamadas que se fueron dando durante la ejecuciÃ³n de un programa hasta que sucediÃ³ un excepciÃ³n
  o un error inesperado.

- Tipado dinÃ¡mico -> Las variables no tienen un tipo de dato particular asociado, podemos asignarle y re-asignarle cualquier valor a cualquier variable.

- Tipado dÃ©bil -> Podemos realizar operaciones entre valores de distintos tipos.

- CoerciÃ³n de tipos -> ConversiÃ³n implÃ­cita de tipos que realiza el motor de JS para poder concretar una operaciÃ³n.

- Tipo de una variable -> Se determina cuando se ejecute la lÃ­nea de cÃ³digo que contiene a esa variable. Depende de la operaciÃ³n que se estÃ¡ realizando con ella.

- Tipos de datos primitivos -> Son tipos de datos bÃ¡sicos, no poseen mÃ©todos ni propiedades, son inmutables.
  strings, number, boolean, null, undefined, symbol, bigint.
- NaN -> Not a Number, es de tipo number y es el resultado de cÃ³mputos invÃ¡lidos.

- Valores falsos -> Valores que van a ser evaluados como false (ademÃ¡s de false): '', 0, null y NaN. Cualquier otro valor va a ser verdadero.

- Object Wrapper -> Objeto que envuelve a un valor primitivo cuando queremos acceder a una propiedad o llamar a un mÃ©todo del mismo.
  Es temporal porque el motor lo utiliza solo por una fracciÃ³n de segundo, despuÃ©s lo desecha, lo borra de la memoria.

Null -> Es el tipo de dato para representar la ausencia de valor. Sirve para decir que una variable no contiene nada, estÃ¡ vacÃ­a
o que todavÃ­a no conocemos su valor. Es un tipo de dato aparte y que solo tiene un valor posible: null.

undefined -> Significa tipo de dato desconocido. Es un valor que deberÃ­amos dejar para que el motor de JS asigne automÃ¡ticamente.
Se muestra undefined cuando aÃºn no se le dio ningÃºn valor, no se recibiÃ³ ese parÃ¡metro,
una funciÃ³n se terminÃ³ de ejecutar hasta el final sin devolver ningÃºn valor.

HEAP -> Es el Ã¡rea de memoria destinada para almacenar objetos.

Referencia -> Es la posiciÃ³n de memoria que se usa para acceder a un objeto.

import / export: Con estas palabras se puede importar y exportar mÃ³dulos.

props -> son la colecciÃ³n de datos que un componente recibe del contenedor padre, y que pueden usarse para definir los elementos de React que retornarÃ¡ el componente.

Pilares de la POO:
AbstracciÃ³n -> Es una manera de reducir la complejidad y permitir un diseÃ±o e implementaciÃ³n mÃ¡s eficientes en sistemas de software complejos.

Encapsulamiento -> Es guardar, proteger, guardar o limitar el acceso de cierto atributos y/o propiedades en nuestros prototipos y objetos.
Cuando hablamos de **encapsulamiento **hablamos de:
Esconder mÃ©todos y atributos ðŸ‘»
No permitir la alteraciÃ³n de mÃ©todos y atributos âŒ

                Encapsulamiento en JavaScript
                No permitir la alteraciÃ³n de mÃ©todos y atributos âŒ

                Formas de aplicar encapsulamiento en JavaScript
                Getters y setters ðŸ–
                Namespaces ðŸ™‚
                Object.defineProperties ðŸŽˆ
                MÃ³dulo de ES6 ðŸ¤

Nota: Se hace uso de los mÃ©todos get y set para limitar la modificaciÃ³n de determinados parÃ¡metros del prototipo clase.
TODO: Investigar mÃ¡s respecto a como se aplican.

Herencia -> Palabra reservada "extends,
Super: La palabra clave super es usada para acceder y llamar funciones del padre de un objeto.

Polimorfismo -> Permite a nuestras subclases cambiar o anular los comportamientos de los mÃ©todos y atributos del prototipo madre, de la clase madre.
Aunque herede las propiedades, el polimorfismo permite cambiar su comportamiento.
Polimorfismo de InclusiÃ³n (JS): La habilidad para redefinir por completo el mÃ©todo de una superclase en una subclase.
El polimorfismo permite sobrescribir mÃ©todos.

static -> Palabra reservada que nos permite acceder a los atributos sin crear un objeto o una instancia de un prototipo (clase).
Nota: El prototipo Object tiene mÃ©todos estÃ¡ticos, por ejemplo(Object.keys, Object.getOwnPropertyNames,Object.entries(), Object.getOwnPropertyDescriptors())).

Las variables son referencias a un espacio en memoria.
ðŸŽ© Los navegadores web usan dos tipos de memorias: Stack y Heap.
ðŸ“ La memoria Stack es muy rÃ¡pida, pero sin tanto espacio. AquÃ­ se guardan los valores primitivos (booleanos, strings, nÃºmerosâ€¦).
ðŸŒª La memoria Heap es mÃ¡s lenta, pero permite guardar enormes cantidades de informaciÃ³n (son como los tornados: grandes, lentos y desordenados). En esta memoria guardamos los valores de los objetos ({...}).

Las variables son una referencia a un espacio en memoria. Dependiendo del tipo de valor que sean serÃ¡n ubicadas en alguna de las dos tipos de memoria:

Stack - Mucho mÃ¡s rÃ¡pida, pero sin tanto espacio
Heap - MÃ¡s lenta, pero con mucho mÃ¡s espacio
Las variables que no tienen un valor de tipo objeto, son almacenadas en la memoria stack. Las variables que tienen como valor un objeto, funcionan de una manera diferente:

El valor (objeto) es guardada en la memoria heap
En la memoria stack se guarda un apuntador (pointer) hacia la memoria heap
Es por esto que cuando nosotros asignamos una variable que tiene como valor un objeto, a una nueva variable, lo Ãºnico que hacemos es asignar el apuntador. Es asÃ­ que al modificar el objeto, en cualquiera de las dos variables, los cambios se reflejan en las dos

Shallow Copy: Se refiere a la forma de crear un nuevo objeto a partir de las propiedades de otro.
Esta copia solo se hace a un nivel alto, no se hace con objetos dentro de objetos (nested objects), lo que provoca que la modificaciÃ³n de una de sus propiedades, modifique el objeto principal.

Recursividad: Es cuando una funciÃ³n se llama a si misma y crea una nueva ejecuciÃ³n de la funciÃ³n.
Ejemplo:

const numeritos = [8, 3, 4, 5, 0, 1, 30, 40];

function recursiva(numbersArray) {
if (numbersArray.length != 0) {
const firstNum = numbersArray[0];
console.log(firstNum);
numbersArray.shift();
recursiva(numbersArray);
}
}

recursiva(numeritos);

RORO: es un patrÃ³n de diseÃ±o que consiste en crear una funciÃ³n que devuelve un objeto.
RO -> Recibir un objeto
RO -> Retornar un objeto
